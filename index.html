<!DOCTYPE html>
<html lang="en">
  <head>
    <title>HeyGen Streaming API LiveKit (V2)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      .avatar-message {
        color: #2563eb;
        font-weight: 600;
      }
      .user-message {
        color: #059669;
        font-weight: 600;
      }
      .status-message {
        color: inherit;
      }
      .current-avatar-message {
        color: #2563eb;
        font-weight: 600;
        opacity: 0.8;
      }
    </style>
  </head>

  <body class="bg-gray-100 p-5 font-sans">
    <div class="max-w-3xl mx-auto bg-white p-5 rounded-lg shadow-md">
      <div class="flex flex-wrap gap-2.5 mb-5">
        <input
          id="avatarID"
          type="text"
          placeholder="Avatar ID"
          value="Wayne_20240711"
          class="flex-1 min-w-[200px] p-2 border border-gray-300 rounded-md"
        />
        <input
          id="voiceID"
          type="text"
          placeholder="Voice ID"
          class="flex-1 min-w-[200px] p-2 border border-gray-300 rounded-md"
        />
        <button
          id="startBtn"
          class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Start
        </button>
        <button
          id="closeBtn"
          class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors"
        >
          Close
        </button>
      </div>

      <div class="flex flex-wrap gap-2.5 mb-5">
        <input
          id="taskInput"
          type="text"
          placeholder="Enter text for avatar to speak"
          class="flex-1 min-w-[200px] p-2 border border-gray-300 rounded-md"
        />
        <button
          id="talkBtn"
          class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors"
        >
          Talk (LLM)
        </button>
        <button
          id="repeatBtn"
          class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
        >
          Repeat
        </button>
      </div>

      <video
        id="mediaElement"
        class="w-full max-h-[400px] border rounded-lg my-5"
        autoplay
      ></video>
      <div
        id="status"
        class="p-2.5 bg-gray-50 border border-gray-300 rounded-md h-[100px] overflow-y-auto font-mono text-sm"
      ></div>
    </div>

    <script>
      // Configuration
      const API_CONFIG = {
        apiKey: "YjAyZmE2YzFlMTkyNDYzNzkxY2E3MmI5Y2RiZWMwMzUtMTc1MTYzMzE2Nw==",
        serverUrl: "https://api.heygen.com",
      };

      // Global variables
      let sessionInfo = null;
      let room = null;
      let mediaStream = null;
      let webSocket = null;
      let sessionToken = null;
      let lastUserMessageTime = 0;
      let currentAvatarResponse = {
        text: "",
        startTime: null,
        isSpeaking: false
      };
      let avatarResponseTimer = null;

      // DOM Elements
      const statusElement = document.getElementById("status");
      const mediaElement = document.getElementById("mediaElement");
      const avatarID = document.getElementById("avatarID");
      const voiceID = document.getElementById("voiceID");
      const taskInput = document.getElementById("taskInput");

      // Helper function to update status
      function updateStatus(message) {
        const timestamp = new Date().toLocaleTimeString();
        statusElement.innerHTML += `<div class="status-message">[${timestamp}] ${message}</div>`;
        statusElement.scrollTop = statusElement.scrollHeight;
      }

      // Function to display user messages
      function displayUserMessage(message) {
        const timestamp = new Date().toLocaleTimeString();
        statusElement.innerHTML += `<div class="user-message">[${timestamp}] You: ${message}</div>`;
        statusElement.scrollTop = statusElement.scrollHeight;
        lastUserMessageTime = Date.now();
      }

      // Function to display partial avatar response
      function displayPartialResponse() {
        const formattedText = currentAvatarResponse.text
          .replace(/\s*([,.!?])\s*/g, '$1 ')
          .replace(/\s+/g, ' ')
          .trim();
        
        // Find or create the avatar message element
        let avatarMsgElement = document.querySelector('.current-avatar-message');
        if (!avatarMsgElement) {
          const timestamp = new Date(currentAvatarResponse.startTime).toLocaleTimeString();
          statusElement.innerHTML += `<div class="current-avatar-message">[${timestamp}] Avatar: ${formattedText}</div>`;
        } else {
          avatarMsgElement.textContent = `[${new Date(currentAvatarResponse.startTime).toLocaleTimeString()}] Avatar: ${formattedText}`;
        }
        
        statusElement.scrollTop = statusElement.scrollHeight;
      }

      // Function to handle avatar speech updates
      function handleAvatarSpeech(message) {
        if (!currentAvatarResponse.startTime) {
          currentAvatarResponse.startTime = Date.now();
        }
        currentAvatarResponse.text += message;
        currentAvatarResponse.isSpeaking = true;
        
        // Display partial response immediately
        displayPartialResponse();
        
        // Clear any existing timer
        if (avatarResponseTimer) {
          clearTimeout(avatarResponseTimer);
        }
        
        // Set a new timer to ensure the message is displayed even if is_final isn't received
        avatarResponseTimer = setTimeout(() => {
          if (currentAvatarResponse.isSpeaking) {
            displayAvatarResponse();
          }
        }, 2000); // 2 seconds after last message part
      }

      // Function to finalize and display avatar response
      function displayAvatarResponse() {
        if (currentAvatarResponse.text.trim() && currentAvatarResponse.startTime) {
          // Remove the temporary class if it exists
          const tempElement = document.querySelector('.current-avatar-message');
          if (tempElement) {
            tempElement.classList.remove('current-avatar-message');
            tempElement.classList.add('avatar-message');
          } else {
            // Only create new message if there wasn't a temporary one
            const timestamp = new Date(currentAvatarResponse.startTime).toLocaleTimeString();
            const formattedText = currentAvatarResponse.text
              .replace(/\s*([,.!?])\s*/g, '$1 ')
              .replace(/\s+/g, ' ')
              .trim();
            
            statusElement.innerHTML += `<div class="avatar-message">[${timestamp}] Avatar: ${formattedText}</div>`;
            statusElement.scrollTop = statusElement.scrollHeight;
          }
        }
        
        // Reset for next response
        currentAvatarResponse = {
          text: "",
          startTime: null,
          isSpeaking: false
        };
      }

      // Get session token
      async function getSessionToken() {
        const response = await fetch(
          `${API_CONFIG.serverUrl}/v1/streaming.create_token`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-Api-Key": API_CONFIG.apiKey,
            },
          }
        );

        const data = await response.json();
        sessionToken = data.data.token;
        updateStatus("Session token obtained");
      }

      // Connect WebSocket
      async function connectWebSocket(sessionId) {
        const params = new URLSearchParams({
          session_id: sessionId,
          session_token: sessionToken,
          silence_response: false,
          opening_text: "Hello, how can I help you?",
          stt_language: "en",
        });

        const wsUrl = `wss://${
          new URL(API_CONFIG.serverUrl).hostname
        }/v1/ws/streaming.chat?${params}`;

        webSocket = new WebSocket(wsUrl);

        webSocket.addEventListener("message", (event) => {
          try {
            const eventData = JSON.parse(event.data);
            
            if (eventData.type === "avatar_talking_message") {
              if (eventData.message) {
                handleAvatarSpeech(eventData.message);
              }
              
              // When avatar stops speaking
              if (eventData.is_final) {
                displayAvatarResponse();
              }
            }
            else if (eventData.type === "status_update") {
              updateStatus(`Status: ${eventData.message}`);
            }
          } catch (e) {
            console.error("Error parsing WebSocket message:", e);
          }
        });

        webSocket.addEventListener("open", () => {
          updateStatus("WebSocket connection established");
        });

        webSocket.addEventListener("close", () => {
          updateStatus("WebSocket connection closed");
        });

        webSocket.addEventListener("error", (error) => {
          updateStatus(`WebSocket error: ${error.message}`);
        });
      }

      // Create new session
      async function createNewSession() {
        if (!sessionToken) {
          await getSessionToken();
        }

        const response = await fetch(
          `${API_CONFIG.serverUrl}/v1/streaming.new`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${sessionToken}`,
            },
            body: JSON.stringify({
              quality: "high",
              avatar_name: avatarID.value,
              voice: {
                voice_id: voiceID.value,
                rate: 1.0,
              },
              version: "v2",
              video_encoding: "H264",
            }),
          }
        );

        const data = await response.json();
        if (!response.ok) {
          console.error("API error:", data);
          updateStatus(`Error: ${data.message || "Invalid request"}`);
          return;
        }
        sessionInfo = data.data;

        // Create LiveKit Room
        room = new LivekitClient.Room({
          adaptiveStream: true,
          dynacast: true,
          videoCaptureDefaults: {
            resolution: LivekitClient.VideoPresets.h720.resolution,
          },
        });

        room.on(LivekitClient.RoomEvent.DataReceived, (message) => {
          try {
            const data = new TextDecoder().decode(message);
            const parsedData = JSON.parse(data);
            
            if (parsedData.type === "avatar_talking_message") {
              if (parsedData.message) {
                handleAvatarSpeech(parsedData.message);
              }
              if (parsedData.is_final) {
                displayAvatarResponse();
              }
            }
          } catch (e) {
            console.error("Error parsing room message:", e);
          }
        });

        // Handle media streams
        mediaStream = new MediaStream();
        room.on(LivekitClient.RoomEvent.TrackSubscribed, (track) => {
          if (track.kind === "video" || track.kind === "audio") {
            mediaStream.addTrack(track.mediaStreamTrack);
            if (
              mediaStream.getVideoTracks().length > 0 &&
              mediaStream.getAudioTracks().length > 0
            ) {
              mediaElement.srcObject = mediaStream;
              updateStatus("Media stream ready");
            }
          }
        });

        // Handle media stream removal
        room.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track) => {
          const mediaTrack = track.mediaStreamTrack;
          if (mediaTrack) {
            mediaStream.removeTrack(mediaTrack);
          }
        });

        // Handle room connection state changes
        room.on(LivekitClient.RoomEvent.Disconnected, (reason) => {
          updateStatus(`Room disconnected: ${reason}`);
        });

        await room.prepareConnection(sessionInfo.url, sessionInfo.access_token);
        updateStatus("Connection prepared");

        // Connect WebSocket after room preparation
        await connectWebSocket(sessionInfo.session_id);

        updateStatus("Session created successfully");
      }

      // Start streaming session
      async function startStreamingSession() {
        const startResponse = await fetch(
          `${API_CONFIG.serverUrl}/v1/streaming.start`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${sessionToken}`,
            },
            body: JSON.stringify({
              session_id: sessionInfo.session_id,
            }),
          }
        );

        // Connect to LiveKit room
        await room.connect(sessionInfo.url, sessionInfo.access_token);
        updateStatus("Connected to room");

        document.querySelector("#startBtn").disabled = true;
        updateStatus("Streaming started successfully");
      }

      // Send text to avatar
      async function sendText(text, taskType = "talk") {
        if (!sessionInfo) {
          updateStatus("No active session");
          return;
        }

        // Display user message immediately
        displayUserMessage(text);

        const response = await fetch(
          `${API_CONFIG.serverUrl}/v1/streaming.task`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${sessionToken}`,
            },
            body: JSON.stringify({
              session_id: sessionInfo.session_id,
              text: text,
              task_type: taskType,
            }),
          }
        );

        // updateStatus(`Sent text (${taskType}): ${text}`);
      }

      // Close session
      async function closeSession() {
        if (!sessionInfo) {
          updateStatus("No active session");
          return;
        }

        // Finalize any pending avatar response
        if (currentAvatarResponse.isSpeaking) {
          displayAvatarResponse();
        }

        // Clear any pending timer
        if (avatarResponseTimer) {
          clearTimeout(avatarResponseTimer);
        }

        const response = await fetch(
          `${API_CONFIG.serverUrl}/v1/streaming.stop`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${sessionToken}`,
            },
            body: JSON.stringify({
              session_id: sessionInfo.session_id,
            }),
          }
        );

        // Close WebSocket
        if (webSocket) {
          webSocket.close();
        }
        // Disconnect from LiveKit room
        if (room) {
          room.disconnect();
        }

        mediaElement.srcObject = null;
        sessionInfo = null;
        room = null;
        mediaStream = null;
        sessionToken = null;
        document.querySelector("#startBtn").disabled = false;

        updateStatus("Session closed");
      }

      // Event Listeners
      document.querySelector("#startBtn").addEventListener("click", async () => {
        await createNewSession();
        await startStreamingSession();
      });
      
      document.querySelector("#closeBtn").addEventListener("click", closeSession);
      
      document.querySelector("#talkBtn").addEventListener("click", () => {
        const text = taskInput.value.trim();
        if (text) {
          sendText(text, "talk");
          taskInput.value = "";
        }
      });
      
      document.querySelector("#repeatBtn").addEventListener("click", () => {
        const text = taskInput.value.trim();
        if (text) {
          sendText(text, "repeat");
          taskInput.value = "";
        }
      });

      // Handle Enter key in task input
      taskInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          const text = taskInput.value.trim();
          if (text) {
            sendText(text, "talk");
            taskInput.value = "";
          }
        }
      });
    </script>
  </body>
</html>