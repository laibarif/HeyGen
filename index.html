<!DOCTYPE html>
<html lang="en">
  <head>
    <title>HeyGen Streaming API LiveKit (V2)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      .avatar-message {
        color: #2563eb;
        font-weight: 600;
      }
      .user-message {
        color: #059669;
        font-weight: 600;
      }
      .status-message {
        color: inherit;
      }
      .current-avatar-message {
        color: #2563eb;
        font-weight: 600;
        opacity: 0.8;
      }
    </style>
  </head>

  <body class="bg-gray-100 p-5 font-sans">
    <div class="max-w-3xl mx-auto bg-white p-5 rounded-lg shadow-md">
      <div class="flex flex-wrap gap-2.5 mb-5">
        <input
          id="avatarID"
          type="text"
          placeholder="Avatar ID"
          value="Wayne_20240711"
          class="flex-1 min-w-[200px] p-2 border border-gray-300 rounded-md"
        />
        <input
          id="voiceID"
          type="text"
          placeholder="Voice ID"
          class="flex-1 min-w-[200px] p-2 border border-gray-300 rounded-md"
        />
        <button
          id="startBtn"
          class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Start
        </button>
        <button
          id="closeBtn"
          class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors"
        >
          Close
        </button>
      </div>

      <div class="flex flex-wrap gap-2.5 mb-5">
        <input
          id="taskInput"
          type="text"
          placeholder="ENTER YOUR MSG"
          class="flex-1 min-w-[200px] p-2 border border-gray-300 rounded-md"
        />
        <button
          id="talkBtn"
          class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors"
        >
          Talk (LLM)
        </button>
      </div>

      <video
        id="mediaElement"
        class="w-full max-h-[400px] border rounded-lg my-5"
        autoplay
      ></video>
      <div
        id="status"
        class="p-2.5 bg-gray-50 border border-gray-300 rounded-md h-[100px] overflow-y-auto font-mono text-sm"
      ></div>
    </div>

    <script>
      // Supabase Configuration
      const SUPABASE_CONFIG = {
        url: "https://lkyfujgwyxpkgtcmhtlv.supabase.co",
        key: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxreWZ1amd3eXhwa2d0Y21odGx2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA5MDA3NTcsImV4cCI6MjA2NjQ3Njc1N30.zkS4p_IaodtfrrD1Xs1Jax9fDkrg_VzPhx1eDolCFOk",
      };
      
      // HeyGen API Configuration
      const API_CONFIG = {
        apiKey: "YjAyZmE2YzFlMTkyNDYzNzkxY2E3MmI5Y2RiZWMwMzUtMTc1MTYzMzE2Nw==",
        serverUrl: "https://api.heygen.com",
      };

      const { createClient } = supabase;
      const supabaseClient = (window.supabase = createClient(
        SUPABASE_CONFIG.url,
        SUPABASE_CONFIG.key
      ));

      // Initialize Supabase client after DOM loads
      document.addEventListener("DOMContentLoaded", async () => {
        // Global variables
        let sessionInfo = null;
        let room = null;
        let mediaStream = null;
        let webSocket = null;
        let sessionToken = null;
        let lastUserMessageTime = 0;
        let currentAvatarResponse = {
          text: "",
          startTime: null,
          isSpeaking: false,
        };
        let avatarResponseTimer = null;
        let chatHistory = [];
        let sessionStartTime = null;
        let isSaving = false; // Flag to prevent duplicate saves

        // DOM Elements
        const statusElement = document.getElementById("status");
        const mediaElement = document.getElementById("mediaElement");
        const avatarID = document.getElementById("avatarID");
        const voiceID = document.getElementById("voiceID");
        const taskInput = document.getElementById("taskInput");

        // Helper function to update status
        function updateStatus(message) {
          const timestamp = new Date().toLocaleTimeString();
          const statusLine = `[${timestamp}] ${message}`;
          statusElement.innerHTML += `<div class="status-message">${statusLine}</div>`;
          statusElement.scrollTop = statusElement.scrollHeight;
          chatHistory.push({
            type: "status",
            message: statusLine,
            timestamp: Date.now(),
          });
        }

        // Function to display user messages
        function displayUserMessage(message) {
          const timestamp = new Date().toLocaleTimeString();
          const userLine = `[${timestamp}] You: ${message}`;
          statusElement.innerHTML += `<div class="user-message">${userLine}</div>`;
          statusElement.scrollTop = statusElement.scrollHeight;
          lastUserMessageTime = Date.now();
          chatHistory.push({
            type: "user",
            message: userLine,
            timestamp: Date.now(),
          });
        }

        // Function to display partial avatar response
        function displayPartialResponse() {
          const formattedText = currentAvatarResponse.text
            .replace(/\s*([,.!?])\s*/g, "$1 ")
            .replace(/\s+/g, " ")
            .trim();

          let avatarMsgElement = document.querySelector(
            ".current-avatar-message"
          );
          const timestamp = new Date(
            currentAvatarResponse.startTime
          ).toLocaleTimeString();
          const avatarLine = `[${timestamp}] Avatar: ${formattedText}`;

          if (!avatarMsgElement) {
            statusElement.innerHTML += `<div class="current-avatar-message">${avatarLine}</div>`;
          } else {
            avatarMsgElement.textContent = avatarLine;
          }

          statusElement.scrollTop = statusElement.scrollHeight;

          const existingIndex = chatHistory.findIndex(
            (item) =>
              item.type === "avatar-partial" &&
              item.startTime === currentAvatarResponse.startTime
          );

          if (existingIndex >= 0) {
            chatHistory[existingIndex].message = avatarLine;
          } else {
            chatHistory.push({
              type: "avatar-partial",
              message: avatarLine,
              startTime: currentAvatarResponse.startTime,
              timestamp: Date.now(),
            });
          }
        }

        // Function to handle avatar speech updates
        function handleAvatarSpeech(message) {
          if (!currentAvatarResponse.startTime) {
            currentAvatarResponse.startTime = Date.now();
          }
          currentAvatarResponse.text += message;
          currentAvatarResponse.isSpeaking = true;

          displayPartialResponse();

          if (avatarResponseTimer) {
            clearTimeout(avatarResponseTimer);
          }

          avatarResponseTimer = setTimeout(() => {
            if (currentAvatarResponse.isSpeaking) {
              displayAvatarResponse();
            }
          }, 2000);
        }

        // Function to finalize and display avatar response
        function displayAvatarResponse() {
          if (
            currentAvatarResponse.text.trim() &&
            currentAvatarResponse.startTime
          ) {
            const tempElement = document.querySelector(
              ".current-avatar-message"
            );
            const timestamp = new Date(
              currentAvatarResponse.startTime
            ).toLocaleTimeString();
            const formattedText = currentAvatarResponse.text
              .replace(/\s*([,.!?])\s*/g, "$1 ")
              .replace(/\s+/g, " ")
              .trim();

            const avatarLine = `[${timestamp}] Avatar: ${formattedText}`;

            if (tempElement) {
              tempElement.classList.remove("current-avatar-message");
              tempElement.classList.add("avatar-message");
              tempElement.textContent = avatarLine;
            } else {
              statusElement.innerHTML += `<div class="avatar-message">${avatarLine}</div>`;
            }

            statusElement.scrollTop = statusElement.scrollHeight;

            chatHistory = chatHistory.filter(
              (item) =>
                !(
                  item.type === "avatar-partial" &&
                  item.startTime === currentAvatarResponse.startTime
                )
            );
            chatHistory.push({
              type: "avatar",
              message: avatarLine,
              timestamp: Date.now(),
            });
          }

          currentAvatarResponse = {
            text: "",
            startTime: null,
            isSpeaking: false,
          };
        }

        // Function to save chat to Supabase
        async function saveChatToDatabase() {
          if (isSaving || chatHistory.length === 0) return;
          isSaving = true;

          const { transcript, sessionData } = formatChatForStorage();

          try {
            const { data, error } = await supabaseClient
              .from("conversation_transcripts")
              .insert([
                {
                  session_id: sessionData.session_id,
                  avatar_id: sessionData.avatar_id,
                  voice_id: sessionData.voice_id,
                  start_time: sessionData.start_time,
                  end_time: sessionData.end_time,
                  full_transcript: transcript,
                  messages: sessionData.messages
                }
              ]);

            if (error) throw error;
            updateStatus("Chat saved to database successfully");
            return true;
          } catch (error) {
            console.error("Supabase error:", error);
            updateStatus(`Error saving to database: ${error.message}`);
            return false;
          } finally {
            isSaving = false;
          }
        }

        // Function to save chat to text file
        function saveChatToTextFile() {
          if (chatHistory.length === 0) {
            updateStatus("No chat history to save");
            return;
          }

          let fullTranscript =
            "Chat Session Transcript\n=======================\n\n";

          if (sessionInfo) {
            fullTranscript += `Session ID: ${sessionInfo.session_id}\n`;
            fullTranscript += `Avatar: ${avatarID.value || "Not specified"}\n`;
            fullTranscript += `Voice: ${voiceID.value || "Not specified"}\n`;
            fullTranscript += `Started: ${new Date(
              sessionStartTime
            ).toLocaleString()}\n`;
            fullTranscript += `Ended: ${new Date().toLocaleString()}\n\n`;
          }

          chatHistory.sort((a, b) => a.timestamp - b.timestamp);
          chatHistory.forEach((item) => {
            if (item.type !== "avatar-partial") {
              fullTranscript += item.message + "\n";
            }
          });

          try {
            const blob = new Blob([fullTranscript], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `chat_session_${
              sessionInfo ? sessionInfo.session_id : ""
            }_${new Date().toISOString().replace(/[:.]/g, "-")}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            updateStatus("Chat saved as text file");
          } catch (error) {
            console.error("Error saving text file:", error);
            updateStatus(`Error saving text file: ${error.message}`);
          }
        }

        // Helper function to format chat for storage
        // Helper function to format chat for storage
function formatChatForStorage() {
  let cleanTranscript = "";
  
  // Filter and format messages
  const filteredMessages = chatHistory.filter(item => 
    item.type === "user" || item.type === "avatar"
  );
  
  filteredMessages.forEach(item => {
    // Extract just the message content without timestamp
    const messageParts = item.message.split('] '); // Split at timestamp
    const messageContent = messageParts.slice(1).join('] '); // Get everything after timestamp
    
    if (item.type === "user") {
      cleanTranscript += `${messageContent}\n`;
    } else if (item.type === "avatar") {
      cleanTranscript += `${messageContent}\n`;
    }
  });

  const sessionData = {
    session_id: sessionInfo ? sessionInfo.session_id : "no-session-id",
    avatar_id: avatarID.value || "not-specified",
    voice_id: voiceID.value || "not-specified",
    start_time: new Date(sessionStartTime).toISOString(),
    end_time: new Date().toISOString(),
    transcript: cleanTranscript.trim(), // Trim any extra whitespace
    messages: chatHistory.filter((item) => item.type !== "avatar-partial")
  };

  return { transcript: cleanTranscript.trim(), sessionData };
}

        // Get session token
        async function getSessionToken() {
          const response = await fetch(
            `${API_CONFIG.serverUrl}/v1/streaming.create_token`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-Api-Key": API_CONFIG.apiKey,
              },
            }
          );

          const data = await response.json();
          sessionToken = data.data.token;
          updateStatus("Session token obtained");
        }

        // Connect WebSocket
        async function connectWebSocket(sessionId) {
          const params = new URLSearchParams({
            session_id: sessionId,
            session_token: sessionToken,
            silence_response: false,
            opening_text: "Hello, how can I help you?",
            stt_language: "en",
          });

          const wsUrl = `wss://${
            new URL(API_CONFIG.serverUrl).hostname
          }/v1/ws/streaming.chat?${params}`;

          webSocket = new WebSocket(wsUrl);

          webSocket.addEventListener("message", (event) => {
            try {
              const eventData = JSON.parse(event.data);

              if (eventData.type === "avatar_talking_message") {
                if (eventData.message) {
                  handleAvatarSpeech(eventData.message);
                }

                if (eventData.is_final) {
                  displayAvatarResponse();
                }
              } else if (eventData.type === "status_update") {
                updateStatus(`Status: ${eventData.message}`);
              }
            } catch (e) {
              console.error("Error parsing WebSocket message:", e);
            }
          });

          webSocket.addEventListener("open", () => {
            updateStatus("WebSocket connection established");
          });

          webSocket.addEventListener("close", () => {
            updateStatus("WebSocket connection closed");
          });

          webSocket.addEventListener("error", (error) => {
            updateStatus(`WebSocket error: ${error.message}`);
          });
        }

        // Create new session
        async function createNewSession() {
          chatHistory = [];
          sessionStartTime = Date.now();

          if (!sessionToken) {
            await getSessionToken();
          }

          const response = await fetch(
            `${API_CONFIG.serverUrl}/v1/streaming.new`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${sessionToken}`,
              },
              body: JSON.stringify({
                quality: "high",
                avatar_name: avatarID.value,
                voice: {
                  voice_id: voiceID.value,
                  rate: 1.0,
                },
                version: "v2",
                video_encoding: "H264",
              }),
            }
          );

          const data = await response.json();
          if (!response.ok) {
            console.error("API error:", data);
            updateStatus(`Error: ${data.message || "Invalid request"}`);
            return;
          }
          sessionInfo = data.data;

          room = new LivekitClient.Room({
            adaptiveStream: true,
            dynacast: true,
            videoCaptureDefaults: {
              resolution: LivekitClient.VideoPresets.h720.resolution,
            },
          });

          room.on(LivekitClient.RoomEvent.DataReceived, (message) => {
            try {
              const data = new TextDecoder().decode(message);
              const parsedData = JSON.parse(data);

              if (parsedData.type === "avatar_talking_message") {
                if (parsedData.message) {
                  handleAvatarSpeech(parsedData.message);
                }
                if (parsedData.is_final) {
                  displayAvatarResponse();
                }
              }
            } catch (e) {
              console.error("Error parsing room message:", e);
            }
          });

          mediaStream = new MediaStream();
          room.on(LivekitClient.RoomEvent.TrackSubscribed, (track) => {
            if (track.kind === "video" || track.kind === "audio") {
              mediaStream.addTrack(track.mediaStreamTrack);
              if (
                mediaStream.getVideoTracks().length > 0 &&
                mediaStream.getAudioTracks().length > 0
              ) {
                mediaElement.srcObject = mediaStream;
                updateStatus("Media stream ready");
              }
            }
          });

          room.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track) => {
            const mediaTrack = track.mediaStreamTrack;
            if (mediaTrack) {
              mediaStream.removeTrack(mediaTrack);
            }
          });

          room.on(LivekitClient.RoomEvent.Disconnected, (reason) => {
            updateStatus(`Room disconnected: ${reason}`);
          });

          await room.prepareConnection(
            sessionInfo.url,
            sessionInfo.access_token
          );
          updateStatus("Connection prepared");

          await connectWebSocket(sessionInfo.session_id);
          updateStatus("Session created successfully");
        }

        // Start streaming session
        async function startStreamingSession() {
          const startResponse = await fetch(
            `${API_CONFIG.serverUrl}/v1/streaming.start`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${sessionToken}`,
              },
              body: JSON.stringify({
                session_id: sessionInfo.session_id,
              }),
            }
          );

          await room.connect(sessionInfo.url, sessionInfo.access_token);
          updateStatus("Connected to room");

          document.querySelector("#startBtn").disabled = true;
          updateStatus("Streaming started successfully");
        }

        // Send text to avatar
        async function sendText(text, taskType = "talk") {
          if (!sessionInfo) {
            updateStatus("No active session");
            return;
          }

          displayUserMessage(text);

          const response = await fetch(
            `${API_CONFIG.serverUrl}/v1/streaming.task`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${sessionToken}`,
              },
              body: JSON.stringify({
                session_id: sessionInfo.session_id,
                text: text,
                task_type: taskType,
              }),
            }
          );
        }

        // Close session
        async function closeSession() {
          if (!sessionInfo) {
            updateStatus("No active session");
            return;
          }

          if (currentAvatarResponse.isSpeaking) {
            displayAvatarResponse();
          }

          if (avatarResponseTimer) {
            clearTimeout(avatarResponseTimer);
          }

          try {
            const response = await fetch(
              `${API_CONFIG.serverUrl}/v1/streaming.stop`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${sessionToken}`,
                },
                body: JSON.stringify({
                  session_id: sessionInfo.session_id,
                }),
              }
            );

            if (webSocket) {
              webSocket.close();
            }
            if (room) {
              room.disconnect();
            }

            mediaElement.srcObject = null;
            document.querySelector("#startBtn").disabled = false;

            // Save to database and text file
            await saveChatToDatabase();
            saveChatToTextFile();

            sessionInfo = null;
            room = null;
            mediaStream = null;
            sessionToken = null;

            updateStatus("Session closed and chat saved");
          } catch (error) {
            console.error("Error closing session:", error);
            updateStatus(`Error closing session: ${error.message}`);
          }
        }

        // Event Listeners
        document
          .querySelector("#startBtn")
          .addEventListener("click", async () => {
            await createNewSession();
            await startStreamingSession();
          });

        document
          .querySelector("#closeBtn")
          .addEventListener("click", closeSession);

        document.querySelector("#talkBtn").addEventListener("click", () => {
          const text = taskInput.value.trim();
          if (text) {
            sendText(text, "talk");
            taskInput.value = "";
          }
        });

        taskInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            const text = taskInput.value.trim();
            if (text) {
              sendText(text, "talk");
              taskInput.value = "";
            }
          }
        });

        window.addEventListener("beforeunload", async (event) => {
          if (sessionInfo) {
            await saveChatToDatabase();
            saveChatToTextFile();
          }
        });
      });
    </script>
  </body>
</html>